<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Math Chalk Background (Vertical / Scroll)</title>

  <style>
    :root{
      --gold:#d6b35a;
      --bg0:#060708;
      --bg1:#0b0e10;
    }

    html, body { height: 100%; }
    body{
      margin:0;
      position:relative;
      background: radial-gradient(1200px 900px at 20% 10%, #11161a 0%, var(--bg1) 35%, var(--bg0) 100%);
      overflow-x:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#eee;
    }

    /* Canvas “largo” que cubre TODO el alto scrolleable */
    #mathBg{
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      z-index:0;
      pointer-events:none;
    }

    /* Tu contenido siempre por encima */
    .page{
      position:relative;
      z-index:1;
      min-height:200vh; /* demo: quita esto en tu web real */
      padding:48px 20px;
    }

    .card{
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      border-radius: 18px;
      background: rgba(0,0,0,.45);
      border: 1px solid rgba(214,179,90,.18);
      backdrop-filter: blur(6px);
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
    }
  </style>
</head>

<body>
  <canvas id="mathBg" aria-hidden="true"></canvas>

  <main class="page">
    <div class="card">Más contenido</div>

    <!-- demo de scroll -->
    <div style="height:140vh"></div>

    <div class="card">Más contenido</div>
  </main>

  <script>
    (() => {
      const canvas = document.getElementById("mathBg");
      const ctx = canvas.getContext("2d", { alpha: true });

      // Polyfill roundRect
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
          r = Math.min(r, w/2, h/2);
          this.beginPath();
          this.moveTo(x+r,y);
          this.arcTo(x+w,y, x+w,y+h, r);
          this.arcTo(x+w,y+h, x,y+h, r);
          this.arcTo(x,y+h, x,y, r);
          this.arcTo(x,y, x+w,y, r);
          this.closePath();
          return this;
        };
      }

      const GOLD = getComputedStyle(document.documentElement).getPropertyValue("--gold").trim() || "#d6b35a";

      // RNG determinista
      let SEED_BASE = 1337;
      let SEED = SEED_BASE;
      function rand() { // xorshift32
        SEED ^= SEED << 13; SEED ^= SEED >>> 17; SEED ^= SEED << 5;
        return ((SEED >>> 0) / 4294967296);
      }
      function r(min, max){ return min + (max - min) * rand(); }
      function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

      // “tiza” / brillo dorado
      function chalkStroke(drawFn, passes = 4) {
        ctx.save();
        ctx.globalCompositeOperation = "screen";
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        for (let i = 0; i < passes; i++) {
          ctx.globalAlpha = r(0.08, 0.18);
          ctx.lineWidth = r(1.0, 2.4);
          ctx.shadowColor = GOLD;
          ctx.shadowBlur = r(8, 18);
          ctx.translate(r(-0.8,0.8), r(-0.8,0.8));
          drawFn();
          ctx.setTransform(1,0,0,1,0,0);
        }
        ctx.restore();
      }

      function calcDpr(cssW, cssH){
        // evita canvas gigantes: cap ~16 megapixeles
        const maxPixels = 16e6;
        const raw = Math.min(1.6, window.devicePixelRatio || 1);
        const pixels = (cssW * raw) * (cssH * raw);
        if (pixels <= maxPixels) return raw;
        const scale = Math.sqrt(maxPixels / (cssW * cssH));
        return Math.max(1, Math.min(raw, scale));
      }

      function bgTexture(w, h) {
        const g = ctx.createRadialGradient(w*0.25, h*0.12, 0, w*0.25, h*0.12, Math.max(w,h)*0.9);
        g.addColorStop(0, "#0f1418");
        g.addColorStop(0.42, "#0a0f12");
        g.addColorStop(1, "#060708");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,w,h);

        // manchas/polvo
        const area = w*h;
        const blobs = clamp(Math.floor(area / 9000), 1800, 12000);
        ctx.save();
        for (let i=0;i<blobs;i++){
          const x = r(0,w), y = r(0,h);
          const rad = r(6, 28);
          ctx.fillStyle = (i%2===0) ? "#ffffff" : "#000000";
          ctx.globalAlpha = r(0.006, 0.028);
          ctx.beginPath();
          ctx.arc(x,y,rad,0,Math.PI*2);
          ctx.fill();
        }
        ctx.restore();

        // ruido fino
        const nw = Math.ceil(w/2), nh = Math.ceil(h/2);
        const img = ctx.createImageData(nw, nh);
        for (let i=0;i<img.data.length;i+=4){
          const v = 120 + Math.floor(rand()*70);
          img.data[i]   = v;
          img.data[i+1] = v;
          img.data[i+2] = v;
          img.data[i+3] = Math.floor(rand()*26);
        }
        const noise = document.createElement("canvas");
        noise.width = nw; noise.height = nh;
        noise.getContext("2d").putImageData(img,0,0);

        ctx.save();
        ctx.globalAlpha = 0.16;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(noise, 0,0, w,h);
        ctx.restore();
      }

      function drawAxes(x, y, w, h) {
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          ctx.moveTo(x, y + h*0.5);
          ctx.lineTo(x + w, y + h*0.5);
          ctx.moveTo(x + w*0.08, y + h);
          ctx.lineTo(x + w*0.08, y);
          ctx.stroke();

          for (let i=0;i<=10;i++){
            const tx = x + w*(i/10);
            ctx.beginPath();
            ctx.moveTo(tx, y + h*0.5 - 5);
            ctx.lineTo(tx, y + h*0.5 + 5);
            ctx.stroke();
          }
          for (let i=0;i<=6;i++){
            const ty = y + h*(i/6);
            ctx.beginPath();
            ctx.moveTo(x + w*0.08 - 5, ty);
            ctx.lineTo(x + w*0.08 + 5, ty);
            ctx.stroke();
          }
        }, 4);
      }

      function plotSine(x, y, w, h) {
        drawAxes(x,y,w,h);
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          const midY = y + h*0.5;
          const amp = h*0.22;
          for (let i=0;i<=260;i++){
            const t = i/260;
            const px = x + w*t;
            const py = midY - Math.sin(t*Math.PI*3.1) * amp;
            if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.stroke();
        }, 5);
      }

      function plotParabola(x, y, w, h) {
        drawAxes(x,y,w,h);
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          for (let i=0;i<=260;i++){
            const t = (i/260)*2 - 1;
            const px = x + (i/260)*w;
            const py = y + h*0.15 + (t*t) * (h*0.55);
            if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
          }
          ctx.stroke();
        }, 4);
      }

      function drawWireCube(cx, cy, size) {
        const s = size, d = size*0.35;
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          ctx.rect(cx - s/2, cy - s/2, s, s);
          ctx.stroke();

          ctx.beginPath();
          ctx.rect(cx - s/2 + d, cy - s/2 - d, s, s);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx - s/2, cy - s/2); ctx.lineTo(cx - s/2 + d, cy - s/2 - d);
          ctx.moveTo(cx + s/2, cy - s/2); ctx.lineTo(cx + s/2 + d, cy - s/2 - d);
          ctx.moveTo(cx - s/2, cy + s/2); ctx.lineTo(cx - s/2 + d, cy + s/2 - d);
          ctx.moveTo(cx + s/2, cy + s/2); ctx.lineTo(cx + s/2 + d, cy + s/2 - d);
          ctx.stroke();
        }, 4);
      }

      function drawWireCone(cx, cy, w, h) {
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          ctx.moveTo(cx, cy - h/2);
          ctx.lineTo(cx - w/2, cy + h/2);
          ctx.lineTo(cx + w/2, cy + h/2);
          ctx.closePath();
          ctx.stroke();

          ctx.beginPath();
          ctx.ellipse(cx, cy + h/2, w/2, w/8, 0, 0, Math.PI*2);
          ctx.stroke();

          ctx.globalAlpha *= 0.65;
          for (let i=0;i<9;i++){
            const t = i/8;
            const bx = cx - w/2 + w*t;
            ctx.beginPath();
            ctx.moveTo(cx, cy - h/2);
            ctx.lineTo(bx, cy + h/2);
            ctx.stroke();
          }
          for (let i=0;i<4;i++){
            const ry = (i+1)/5;
            ctx.beginPath();
            ctx.ellipse(cx, cy + h/2 - h*0.55*ry, w/2*(1-ry*0.55), w/9*(1-ry*0.55), 0, 0, Math.PI*2);
            ctx.stroke();
          }
        }, 4);
      }

      function drawPie(cx, cy, r0) {
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          ctx.arc(cx, cy, r0, 0, Math.PI*2);
          ctx.stroke();

          const angles = [0.0, 1.1, 2.3, 3.8, 5.2, 6.283];
          for (let i=0;i<angles.length-1;i++){
            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(cx + Math.cos(angles[i]) * r0, cy + Math.sin(angles[i]) * r0);
            ctx.stroke();
          }

          ctx.globalAlpha *= 0.45;
          for (let k=0;k<34;k++){
            const a = r(0.15, 1.05);
            ctx.beginPath();
            ctx.moveTo(cx,cy);
            ctx.lineTo(cx + Math.cos(a) * r0, cy + Math.sin(a) * r0);
            ctx.stroke();
          }
        }, 3);
      }

      function drawCalculator(x, y, w, h) {
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.roundRect(x, y, w, h, 12);
          ctx.stroke();

          ctx.beginPath();
          ctx.roundRect(x+w*0.12, y+h*0.10, w*0.76, h*0.18, 8);
          ctx.stroke();

          const cols=4, rows=4;
          const bx = x+w*0.14, by = y+h*0.35;
          const bw = w*0.72, bh = h*0.55;
          const gap = w*0.03;
          const cellW = (bw - gap*(cols-1))/cols;
          const cellH = (bh - gap*(rows-1))/rows;
          for(let rI=0;rI<rows;rI++){
            for(let cI=0;cI<cols;cI++){
              ctx.beginPath();
              ctx.roundRect(
                bx + cI*(cellW+gap),
                by + rI*(cellH+gap),
                cellW,
                cellH,
                6
              );
              ctx.stroke();
            }
          }
        }, 3);
      }

      function drawCompass(cx, cy, s) {
        chalkStroke(() => {
          ctx.strokeStyle = GOLD;
          ctx.beginPath();
          ctx.moveTo(cx, cy - s*0.55);
          ctx.lineTo(cx - s*0.30, cy + s*0.50);
          ctx.moveTo(cx, cy - s*0.55);
          ctx.lineTo(cx + s*0.30, cy + s*0.50);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx, cy - s*0.58, s*0.06, 0, Math.PI*2);
          ctx.stroke();
        }, 3);
      }

      function drawEquation(x, y, text, size=20, rot=0) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rot);
        ctx.font = `600 ${size}px ui-serif, "Times New Roman", Georgia, serif`;
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        for (let i=0;i<3;i++){
          ctx.globalAlpha = 0.10 + i*0.06;
          ctx.fillStyle = GOLD;
          ctx.shadowColor = GOLD;
          ctx.shadowBlur = 10 + i*6;
          ctx.fillText(text, r(-1,1), r(-1,1));
        }
        ctx.restore();
      }

      function sprinkleEquations(w, h) {
        const eqs = [
          "e = mc²","y = mx + b","x² + y² = r²","∫ f(x) dx","∑ (1/n²)",
          "Δ = b² − 4ac","sin(x), cos(x)","log(a·b)=log a + log b",
          "P(A|B)=P(A∩B)/P(B)","aₙ=a₁+(n−1)d","f'(x)","π≈3.1416"
        ];

        const area = w*h;
        const count = clamp(Math.floor(area/65000), 80, 520);

        for (let i=0;i<count;i++){
          const tx = r(18, w-320);
          const ty = r(30, h-30);
          const s  = r(16, 26);
          const rot = r(-0.16, 0.16);
          drawEquation(tx, ty, eqs[(rand()*eqs.length)|0], s, rot);
        }
      }

      function vignette(w,h){
        const vg = ctx.createRadialGradient(w*0.5, h*0.35, Math.min(w,h)*0.25, w*0.5, h*0.5, Math.max(w,h)*0.95);
        vg.addColorStop(0, "rgba(0,0,0,0)");
        vg.addColorStop(1, "rgba(0,0,0,0.62)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,w,h);
      }

      function drawTallLayout(w,h){
        const s = Math.min(w, h) * 0.22;

        drawWireCone(w*0.32, h*0.12, s*1.05, s*0.95);
        drawWireCube(w*0.78, h*0.10, s*0.72);
        plotParabola(w*0.05, h*0.05, Math.min(420, w*0.38), Math.min(210, h*0.12));

        plotSine(w*0.40, h*0.22, Math.min(620, w*0.55), Math.min(240, h*0.13));
        plotSine(w*0.06, h*0.28, Math.min(520, w*0.45), Math.min(210, h*0.12));

        plotParabola(w*0.48, h*0.34, Math.min(640, w*0.50), Math.min(280, h*0.15));

        plotSine(w*0.06, h*0.52, Math.min(520, w*0.45), Math.min(220, h*0.12));
        plotSine(w*0.40, h*0.58, Math.min(520, w*0.45), Math.min(220, h*0.12));

        drawCompass(w*0.16, h*0.77, s*0.85);
        drawPie(w*0.40, h*0.80, s*0.55);
        drawCalculator(w*0.68, h*0.70, Math.min(280, w*0.24), Math.min(360, h*0.18));

        plotParabola(w*0.10, h*0.86, Math.min(420, w*0.36), Math.min(220, h*0.12));
        plotParabola(w*0.48, h*0.86, Math.min(520, w*0.45), Math.min(240, h*0.13));

        // repetición suave por bloques para páginas muy largas
        const step = 850;
        for (let y=0; y<h; y+=step){
          const old = SEED;
          SEED = (SEED_BASE + (y|0)) >>> 0;

          const gx = r(w*0.08, w*0.60);
          const gy = y + r(120, step-120);
          const gw = Math.min(420, w*0.36);
          const gh = Math.min(210, 180);
          plotSine(gx, gy, gw, gh);

          SEED = old;
        }
      }

      function syncSizeAndDraw(){
        const cssW = document.documentElement.clientWidth;
        const cssH = Math.max(
          document.documentElement.scrollHeight,
          document.body.scrollHeight,
          window.innerHeight
        );

        const dpr = calcDpr(cssW, cssH);
        canvas.width  = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);
        canvas.style.width  = cssW + "px";
        canvas.style.height = cssH + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        SEED = SEED_BASE;
        ctx.clearRect(0,0,cssW,cssH);

        bgTexture(cssW, cssH);
        sprinkleEquations(cssW, cssH);
        drawTallLayout(cssW, cssH);
        vignette(cssW, cssH);
      }

      let raf = 0;
      function requestRedraw(){
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(syncSizeAndDraw);
      }

      window.addEventListener("resize", requestRedraw, {passive:true});

      const ro = new ResizeObserver(requestRedraw);
      ro.observe(document.documentElement);

      syncSizeAndDraw();
    })();
  </script>
</body>
</html>
